{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-core\n * Generated: 2018-12-25\n * Version: 1.10.0\n * License: https://js.devexpress.com/Licensing\n */\nimport { createContext, createElement, Children, PureComponent, Component, createRef } from 'react';\nimport { node, object, func, string, arrayOf, shape, bool, any, oneOfType, instanceOf } from 'prop-types';\nimport { shallowEqual, PluginHost, EventEmitter } from '@devexpress/dx-core';\nimport { findDOMNode, unstable_batchedUpdates } from 'react-dom';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nvar PluginHostContext = createContext();\nvar PositionContext = createContext();\nvar TemplateHostContext = createContext();\n\nvar PluginIndexer = function PluginIndexer(_ref) {\n  var children = _ref.children;\n  return createElement(PositionContext.Consumer, null, function (positionContext) {\n    return Children.map(children, function (child, index) {\n      if (!child || !child.type) return child;\n\n      var childPosition = function childPosition() {\n        var calculatedPosition = positionContext && positionContext() || [];\n        return [].concat(_toConsumableArray(calculatedPosition), [index]);\n      };\n\n      return createElement(PositionContext.Provider, {\n        value: childPosition\n      }, child);\n    });\n  });\n};\n\nprocess.env.NODE_ENV !== \"production\" ? PluginIndexer.propTypes = {\n  children: node\n} : void 0;\nPluginIndexer.defaultProps = {\n  children: undefined\n};\nvar PLUGIN_HOST_CONTEXT = 'dxcore_pluginHost_context';\nvar POSITION_CONTEXT = 'dxcore_position_context';\nvar TEMPLATE_HOST_CONTEXT = 'dxcore_templateHost_context';\nvar RERENDER_TEMPLATE_EVENT = Symbol('rerenderTemplate');\nvar RERENDER_TEMPLATE_SCOPE_EVENT = Symbol('rerenderTemplateScope');\nvar UPDATE_CONNECTION_EVENT = Symbol('updateConnection');\n\nvar withContext = function withContext(Context, name) {\n  return function (Component$$1) {\n    return function (props) {\n      return createElement(Context.Consumer, null, function (context) {\n        return createElement(Component$$1, _extends({}, props, _defineProperty({}, name, context)));\n      });\n    };\n  };\n};\n\nvar withHostAndPosition = function withHostAndPosition(Component$$1) {\n  return withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(PositionContext, POSITION_CONTEXT)(Component$$1));\n};\n\nvar _PluginBase$propTypes;\n\nvar PluginBase =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(PluginBase, _React$PureComponent);\n\n  function PluginBase() {\n    _classCallCheck(this, PluginBase);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PluginBase).apply(this, arguments));\n  }\n\n  _createClass(PluginBase, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          pluginHost = _this$props[PLUGIN_HOST_CONTEXT],\n          position = _this$props[POSITION_CONTEXT];\n      var _this$props2 = this.props,\n          name = _this$props2.name,\n          dependencies = _this$props2.dependencies;\n      this.plugin = {\n        position: position,\n        name: name,\n        dependencies: dependencies,\n        container: true\n      };\n      pluginHost.registerPlugin(this.plugin);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.ensureDependencies();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.unregisterPlugin(this.plugin);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return createElement(PluginIndexer, null, children);\n    }\n  }]);\n\n  return PluginBase;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? PluginBase.propTypes = (_PluginBase$propTypes = {}, _defineProperty(_PluginBase$propTypes, PLUGIN_HOST_CONTEXT, object.isRequired), _defineProperty(_PluginBase$propTypes, POSITION_CONTEXT, func.isRequired), _defineProperty(_PluginBase$propTypes, \"children\", node.isRequired), _defineProperty(_PluginBase$propTypes, \"name\", string), _defineProperty(_PluginBase$propTypes, \"dependencies\", arrayOf(shape({\n  name: string,\n  optional: bool\n}))), _PluginBase$propTypes) : void 0;\nPluginBase.defaultProps = {\n  name: '',\n  dependencies: []\n};\nvar Plugin = withHostAndPosition(PluginBase);\n\nvar _TemplatePlaceholderB, _TemplatePlaceholderB2;\n\nvar TemplatePlaceholderBase =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TemplatePlaceholderBase, _React$Component);\n\n  function TemplatePlaceholderBase(props) {\n    var _this$subscription;\n\n    var _this;\n\n    _classCallCheck(this, TemplatePlaceholderBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TemplatePlaceholderBase).call(this, props));\n    var propsName = _this.props.name;\n    _this.subscription = (_this$subscription = {}, _defineProperty(_this$subscription, RERENDER_TEMPLATE_EVENT, function (id) {\n      if (_this.template && _this.template.id === id) {\n        _this.forceUpdate();\n      }\n    }), _defineProperty(_this$subscription, RERENDER_TEMPLATE_SCOPE_EVENT, function (name) {\n      if (propsName === name) {\n        _this.forceUpdate();\n      }\n    }), _this$subscription);\n    return _this;\n  }\n\n  _createClass(TemplatePlaceholderBase, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.registerSubscription(this.subscription);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var _this$getRenderingDat = this.getRenderingData(nextProps),\n          params = _this$getRenderingDat.params;\n\n      var children = this.props.children;\n      return !shallowEqual(params, this.params) || children !== nextProps.children;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.unregisterSubscription(this.subscription);\n    }\n  }, {\n    key: \"getRenderingData\",\n    value: function getRenderingData(props) {\n      var name = props.name,\n          params = props.params;\n\n      if (name) {\n        var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n        return {\n          params: params,\n          templates: pluginHost.collect(\"\".concat(name, \"Template\")).filter(function (template) {\n            return template.predicate(params);\n          }).reverse()\n        };\n      }\n\n      var templateHost = this.props[TEMPLATE_HOST_CONTEXT];\n      return {\n        params: params || templateHost.params(),\n        templates: templateHost.templates()\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$getRenderingDat2 = this.getRenderingData(this.props),\n          params = _this$getRenderingDat2.params,\n          templates = _this$getRenderingDat2.templates;\n\n      this.params = params;\n\n      var _templates = _slicedToArray(templates, 1);\n\n      this.template = _templates[0];\n      this.restTemplates = templates.slice(1);\n      var content = null;\n\n      if (this.template) {\n        var templateContent = this.template.children;\n        content = templateContent() || null;\n\n        if (content && typeof content === 'function') {\n          content = content(params);\n        }\n      }\n\n      var templatePlaceholder = this.props.children;\n      return createElement(TemplateHostContext.Provider, {\n        value: {\n          templates: function templates() {\n            return _this2.restTemplates;\n          },\n          params: function params() {\n            return _this2.params;\n          }\n        }\n      }, templatePlaceholder ? templatePlaceholder(content) : content);\n    }\n  }]);\n\n  return TemplatePlaceholderBase;\n}(Component);\n\nprocess.env.NODE_ENV !== \"production\" ? TemplatePlaceholderBase.propTypes = (_TemplatePlaceholderB = {\n  name: string,\n  // eslint-disable-line react/no-unused-prop-types\n  params: object\n}, _defineProperty(_TemplatePlaceholderB, TEMPLATE_HOST_CONTEXT, object), _defineProperty(_TemplatePlaceholderB, PLUGIN_HOST_CONTEXT, object.isRequired), _defineProperty(_TemplatePlaceholderB, \"children\", func), _TemplatePlaceholderB) : void 0;\nTemplatePlaceholderBase.defaultProps = (_TemplatePlaceholderB2 = {}, _defineProperty(_TemplatePlaceholderB2, TEMPLATE_HOST_CONTEXT, undefined), _defineProperty(_TemplatePlaceholderB2, \"name\", undefined), _defineProperty(_TemplatePlaceholderB2, \"params\", undefined), _defineProperty(_TemplatePlaceholderB2, \"children\", undefined), _TemplatePlaceholderB2);\nvar TemplatePlaceholder = withContext(PluginHostContext, PLUGIN_HOST_CONTEXT)(withContext(TemplateHostContext, TEMPLATE_HOST_CONTEXT)(TemplatePlaceholderBase));\n\nvar PluginHost$1 =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(PluginHost$$1, _React$PureComponent);\n\n  function PluginHost$$1(props) {\n    var _this;\n\n    _classCallCheck(this, PluginHost$$1);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PluginHost$$1).call(this, props));\n    _this.host = new PluginHost();\n    return _this;\n  }\n\n  _createClass(PluginHost$$1, [{\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return createElement(PluginHostContext.Provider, {\n        value: this.host\n      }, createElement(PluginIndexer, null, children), createElement(TemplatePlaceholder, {\n        name: \"root\"\n      }));\n    }\n  }]);\n\n  return PluginHost$$1;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? PluginHost$1.propTypes = {\n  children: node\n} : void 0;\nPluginHost$1.defaultProps = {\n  children: undefined\n};\n\nvar getAvailableGetters = function getAvailableGetters(pluginHost) {\n  var getGetterValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (getterName) {\n    return pluginHost.get(\"\".concat(getterName, \"Getter\"));\n  };\n  var trackedDependencies = {};\n  var getters;\n\n  if (typeof Proxy !== 'undefined') {\n    getters = new Proxy({}, {\n      get: function get(target, prop) {\n        if (typeof prop !== 'string') return undefined;\n        var result = getGetterValue(prop);\n        trackedDependencies[prop] = result;\n        return result;\n      },\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n        return {\n          configurable: true,\n          enumerable: true,\n          value: this.get(target, prop)\n        };\n      },\n      ownKeys: function ownKeys() {\n        return pluginHost.knownKeys('Getter');\n      }\n    });\n  } else {\n    getters = pluginHost.knownKeys('Getter').reduce(function (acc, getterName) {\n      Object.defineProperty(acc, getterName, {\n        get: function get() {\n          var result = getGetterValue(getterName);\n          trackedDependencies[getterName] = result;\n          return result;\n        }\n      });\n      return acc;\n    }, {});\n  }\n\n  return {\n    getters: getters,\n    trackedDependencies: trackedDependencies\n  };\n};\n\nvar isTrackedDependenciesChanged = function isTrackedDependenciesChanged(pluginHost, prevTrackedDependencies) {\n  var getGetterValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (getterName) {\n    return pluginHost.get(\"\".concat(getterName, \"Getter\"));\n  };\n  var trackedDependencies = Object.keys(prevTrackedDependencies).reduce(function (acc, getterName) {\n    return Object.assign(acc, _defineProperty({}, getterName, getGetterValue(getterName)));\n  }, {});\n  return !shallowEqual(prevTrackedDependencies, trackedDependencies);\n};\n\nvar getAvailableActions = function getAvailableActions(pluginHost) {\n  var getAction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (actionName) {\n    return pluginHost.collect(\"\".concat(actionName, \"Action\")).slice().reverse()[0];\n  };\n  var actions;\n\n  if (typeof Proxy !== 'undefined') {\n    actions = new Proxy({}, {\n      get: function get(target, prop) {\n        if (typeof prop !== 'string') return undefined;\n        return getAction(prop);\n      },\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, prop) {\n        return {\n          configurable: true,\n          enumerable: true,\n          value: this.get(target, prop)\n        };\n      },\n      ownKeys: function ownKeys() {\n        return pluginHost.knownKeys('Action');\n      }\n    });\n  } else {\n    actions = pluginHost.knownKeys('Action').reduce(function (acc, actionName) {\n      Object.defineProperty(acc, actionName, {\n        get: function get() {\n          return getAction(actionName);\n        }\n      });\n      return acc;\n    }, {});\n  }\n\n  return actions;\n};\n\nvar _ActionBase$propTypes;\n\nvar ActionBase =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(ActionBase, _React$PureComponent);\n\n  function ActionBase(props) {\n    var _this;\n\n    _classCallCheck(this, ActionBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ActionBase).call(this, props));\n    var pluginHost = props[PLUGIN_HOST_CONTEXT],\n        positionContext = props[POSITION_CONTEXT];\n    var name = props.name;\n    _this.plugin = _defineProperty({\n      position: function position() {\n        return positionContext();\n      }\n    }, \"\".concat(name, \"Action\"), function Action(params) {\n      var action = _this.props.action;\n\n      var _getAvailableGetters = getAvailableGetters(pluginHost, function (getterName) {\n        return pluginHost.get(\"\".concat(getterName, \"Getter\"), _this.plugin);\n      }),\n          getters = _getAvailableGetters.getters;\n\n      var nextParams = params;\n      var actions = getAvailableActions(pluginHost, function (actionName) {\n        return actionName === name ? function (newParams) {\n          nextParams = newParams;\n        } : pluginHost.collect(\"\".concat(actionName, \"Action\"), _this.plugin).slice().reverse()[0];\n      });\n      action(params, getters, actions);\n      var nextAction = pluginHost.collect(\"\".concat(name, \"Action\"), _this.plugin).slice().reverse()[0];\n\n      if (nextAction) {\n        nextAction(nextParams);\n      }\n    });\n    pluginHost.registerPlugin(_this.plugin);\n    return _this;\n  }\n\n  _createClass(ActionBase, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.unregisterPlugin(this.plugin);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return ActionBase;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? ActionBase.propTypes = (_ActionBase$propTypes = {\n  name: string.isRequired,\n  action: func.isRequired\n}, _defineProperty(_ActionBase$propTypes, PLUGIN_HOST_CONTEXT, object.isRequired), _defineProperty(_ActionBase$propTypes, POSITION_CONTEXT, func.isRequired), _ActionBase$propTypes) : void 0;\nvar Action = withHostAndPosition(ActionBase);\n\nvar _GetterBase$propTypes;\n\nvar GetterBase =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(GetterBase, _React$PureComponent);\n\n  function GetterBase(props) {\n    var _this;\n\n    _classCallCheck(this, GetterBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(GetterBase).call(this, props));\n    var pluginHost = props[PLUGIN_HOST_CONTEXT],\n        positionContext = props[POSITION_CONTEXT];\n    var name = props.name;\n    var lastComputed;\n    var lastTrackedDependencies = {};\n    var lastResult;\n    _this.plugin = _defineProperty({\n      position: function position() {\n        return positionContext();\n      }\n    }, \"\".concat(name, \"Getter\"), function Getter(original) {\n      var _this$props = _this.props,\n          value = _this$props.value,\n          computed = _this$props.computed;\n      if (computed === undefined) return value;\n\n      var getGetterValue = function getGetterValue(getterName) {\n        return getterName === name ? original : pluginHost.get(\"\".concat(getterName, \"Getter\"), _this.plugin);\n      };\n\n      if (computed === lastComputed && !isTrackedDependenciesChanged(pluginHost, lastTrackedDependencies, getGetterValue)) {\n        return lastResult;\n      }\n\n      var _getAvailableGetters = getAvailableGetters(pluginHost, getGetterValue),\n          getters = _getAvailableGetters.getters,\n          trackedDependencies = _getAvailableGetters.trackedDependencies;\n\n      var actions = getAvailableActions(pluginHost);\n      lastComputed = computed;\n      lastTrackedDependencies = trackedDependencies;\n      lastResult = computed(getters, actions);\n      return lastResult;\n    });\n    pluginHost.registerPlugin(_this.plugin);\n    return _this;\n  }\n\n  _createClass(GetterBase, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.broadcast(UPDATE_CONNECTION_EVENT);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.unregisterPlugin(this.plugin);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return GetterBase;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? GetterBase.propTypes = (_GetterBase$propTypes = {\n  name: string.isRequired,\n  value: any,\n  computed: func\n}, _defineProperty(_GetterBase$propTypes, PLUGIN_HOST_CONTEXT, object.isRequired), _defineProperty(_GetterBase$propTypes, POSITION_CONTEXT, func.isRequired), _GetterBase$propTypes) : void 0;\nGetterBase.defaultProps = {\n  value: undefined,\n  computed: undefined\n};\nvar Getter = withHostAndPosition(GetterBase);\n\nvar _TemplateBase$propTyp;\n\nvar globalTemplateId = 0;\n\nvar TemplateBase =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(TemplateBase, _React$PureComponent);\n\n  function TemplateBase(props) {\n    var _this;\n\n    _classCallCheck(this, TemplateBase);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TemplateBase).call(this, props));\n    globalTemplateId += 1;\n    _this.id = globalTemplateId;\n    var pluginHost = props[PLUGIN_HOST_CONTEXT],\n        positionContext = props[POSITION_CONTEXT];\n    var name = props.name,\n        _predicate = props.predicate;\n    _this.plugin = _defineProperty({\n      position: function position() {\n        return positionContext();\n      }\n    }, \"\".concat(name, \"Template\"), {\n      id: _this.id,\n      predicate: function predicate(params) {\n        return _predicate ? _predicate(params) : true;\n      },\n      children: function children() {\n        var children = _this.props.children;\n        return children;\n      }\n    });\n    pluginHost.registerPlugin(_this.plugin);\n    pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);\n    return _this;\n  }\n\n  _createClass(TemplateBase, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      pluginHost.broadcast(RERENDER_TEMPLATE_EVENT, this.id);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.props[PLUGIN_HOST_CONTEXT];\n      var name = this.props.name;\n      pluginHost.unregisterPlugin(this.plugin);\n      pluginHost.broadcast(RERENDER_TEMPLATE_SCOPE_EVENT, name);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return TemplateBase;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? TemplateBase.propTypes = (_TemplateBase$propTyp = {}, _defineProperty(_TemplateBase$propTyp, PLUGIN_HOST_CONTEXT, object.isRequired), _defineProperty(_TemplateBase$propTyp, POSITION_CONTEXT, func.isRequired), _defineProperty(_TemplateBase$propTyp, \"name\", string.isRequired), _defineProperty(_TemplateBase$propTyp, \"predicate\", func), _defineProperty(_TemplateBase$propTyp, \"children\", oneOfType([func, node])), _TemplateBase$propTyp) : void 0;\nTemplateBase.defaultProps = {\n  predicate: undefined,\n  children: undefined\n};\nvar Template = withHostAndPosition(TemplateBase);\n\nvar TemplateConnector =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(TemplateConnector, _React$Component);\n\n  function TemplateConnector(props, context) {\n    var _this;\n\n    _classCallCheck(this, TemplateConnector);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TemplateConnector).call(this, props, context));\n    _this.trackedDependencies = {};\n    _this.subscription = _defineProperty({}, UPDATE_CONNECTION_EVENT, function () {\n      return _this.updateConnection();\n    });\n    return _this;\n  }\n\n  _createClass(TemplateConnector, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var pluginHost = this.context;\n      pluginHost.registerSubscription(this.subscription);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var pluginHost = this.context;\n      pluginHost.unregisterSubscription(this.subscription);\n    }\n  }, {\n    key: \"updateConnection\",\n    value: function updateConnection() {\n      var pluginHost = this.context;\n\n      if (isTrackedDependenciesChanged(pluginHost, this.trackedDependencies)) {\n        this.forceUpdate();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var pluginHost = this.context;\n      var children = this.props.children;\n\n      var _getAvailableGetters = getAvailableGetters(pluginHost),\n          getters = _getAvailableGetters.getters,\n          trackedDependencies = _getAvailableGetters.trackedDependencies;\n\n      this.trackedDependencies = trackedDependencies;\n      var actions = getAvailableActions(pluginHost);\n      return children(getters, actions);\n    }\n  }]);\n\n  return TemplateConnector;\n}(Component);\n\nprocess.env.NODE_ENV !== \"production\" ? TemplateConnector.propTypes = {\n  children: func.isRequired\n} : void 0;\nTemplateConnector.contextType = PluginHostContext;\nvar TIMEOUT = 180;\n\nvar TouchStrategy =\n/*#__PURE__*/\nfunction () {\n  function TouchStrategy(delegate) {\n    _classCallCheck(this, TouchStrategy);\n\n    this.delegate = delegate;\n    this.touchStartTimeout = null;\n    this.dragging = false;\n  }\n\n  _createClass(TouchStrategy, [{\n    key: \"isDragging\",\n    value: function isDragging() {\n      return this.dragging;\n    }\n  }, {\n    key: \"isWaiting\",\n    value: function isWaiting() {\n      return !!this.touchStartTimeout;\n    }\n  }, {\n    key: \"cancelWaiting\",\n    value: function cancelWaiting() {\n      clearTimeout(this.touchStartTimeout);\n      this.touchStartTimeout = null;\n    }\n  }, {\n    key: \"start\",\n    value: function start(e) {\n      var _this = this;\n\n      var _e$touches$ = e.touches[0],\n          x = _e$touches$.clientX,\n          y = _e$touches$.clientY;\n      this.touchStartTimeout = setTimeout(function () {\n        _this.delegate.onStart({\n          x: x,\n          y: y\n        });\n\n        _this.dragging = true;\n      }, TIMEOUT);\n    }\n  }, {\n    key: \"move\",\n    value: function move(e) {\n      this.cancelWaiting();\n\n      if (this.dragging) {\n        var _e$touches$2 = e.touches[0],\n            clientX = _e$touches$2.clientX,\n            clientY = _e$touches$2.clientY;\n        e.preventDefault();\n        this.delegate.onMove({\n          x: clientX,\n          y: clientY\n        });\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(e) {\n      this.cancelWaiting();\n\n      if (this.dragging) {\n        var _e$changedTouches$ = e.changedTouches[0],\n            clientX = _e$changedTouches$.clientX,\n            clientY = _e$changedTouches$.clientY;\n        this.delegate.onEnd({\n          x: clientX,\n          y: clientY\n        });\n      }\n\n      this.mouseInitialOffset = null;\n      this.dragging = false;\n    }\n  }]);\n\n  return TouchStrategy;\n}();\n/* globals document:true */\n\n\nvar gestureCover = null;\n\nvar toggleGestureCover = function toggleGestureCover(toggle, cursor) {\n  var style = {\n    pointerEvents: toggle ? 'all' : 'none'\n  };\n\n  if (toggle && cursor) {\n    style = _objectSpread({}, style, {\n      cursor: cursor\n    });\n  }\n\n  if (!gestureCover) {\n    style = _objectSpread({}, style, {\n      position: 'fixed',\n      top: 0,\n      right: 0,\n      left: 0,\n      bottom: 0,\n      opacity: 0,\n      zIndex: 2147483647\n    });\n    gestureCover = document.createElement('div');\n    document.body.appendChild(gestureCover);\n  }\n\n  Object.keys(style).forEach(function (key) {\n    gestureCover.style[key] = style[key];\n  });\n};\n\nvar BOUNDARY = 10;\n\nvar clamp = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar isBoundExceeded = function isBoundExceeded(_ref, _ref2) {\n  var initialX = _ref.x,\n      initialY = _ref.y;\n  var x = _ref2.x,\n      y = _ref2.y;\n  return clamp(x, initialX - BOUNDARY, initialX + BOUNDARY) !== x || clamp(y, initialY - BOUNDARY, initialY + BOUNDARY) !== y;\n};\n\nvar MouseStrategy =\n/*#__PURE__*/\nfunction () {\n  function MouseStrategy(delegate) {\n    _classCallCheck(this, MouseStrategy);\n\n    this.delegate = delegate;\n    this.mouseInitialOffset = null;\n    this.dragging = false;\n  }\n\n  _createClass(MouseStrategy, [{\n    key: \"isDragging\",\n    value: function isDragging() {\n      return this.dragging;\n    }\n  }, {\n    key: \"start\",\n    value: function start(e) {\n      var x = e.clientX,\n          y = e.clientY;\n      this.e = e;\n      this.mouseInitialOffset = {\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"move\",\n    value: function move(e) {\n      var x = e.clientX,\n          y = e.clientY;\n      var dragStarted = false;\n\n      if (!this.dragging && this.mouseInitialOffset) {\n        if (isBoundExceeded(this.mouseInitialOffset, {\n          x: x,\n          y: y\n        })) {\n          this.delegate.onStart(this.mouseInitialOffset);\n\n          if (window.getSelection) {\n            window.getSelection().removeAllRanges();\n          }\n\n          dragStarted = true;\n          this.dragging = true;\n        }\n      }\n\n      if (this.dragging) {\n        e.preventDefault();\n        this.delegate.onMove({\n          x: x,\n          y: y\n        });\n      }\n\n      if (dragStarted) {\n        var _window$getComputedSt = window.getComputedStyle(document.elementFromPoint(x, y)),\n            cursor = _window$getComputedSt.cursor;\n\n        toggleGestureCover(true, cursor);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(e) {\n      if (this.dragging) {\n        var x = e.clientX,\n            y = e.clientY;\n        toggleGestureCover(false);\n        this.delegate.onEnd({\n          x: x,\n          y: y\n        });\n      }\n\n      this.mouseInitialOffset = null;\n      this.dragging = false;\n    }\n  }]);\n\n  return MouseStrategy;\n}();\n/* globals window:true */\n\n\nvar eventEmitter = null;\n\nvar getSharedEventEmitter = function getSharedEventEmitter() {\n  if (!eventEmitter) {\n    eventEmitter = new EventEmitter();\n    ['mousemove', 'mouseup', 'touchmove', 'touchend', 'touchcancel'].forEach(function (name) {\n      return window.addEventListener(name, function (e) {\n        return eventEmitter.emit([name, e]);\n      }, {\n        passive: false\n      });\n    });\n  }\n\n  return eventEmitter;\n};\n/* globals document:true window:true */\n\n\nvar clear = function clear() {\n  if (window.getSelection) {\n    if (window.getSelection().empty) {\n      window.getSelection().empty();\n    } else if (window.getSelection().removeAllRanges) {\n      window.getSelection().removeAllRanges();\n    }\n  } else if (document.selection) {\n    document.selection.empty();\n  }\n};\n\nvar draggingHandled = Symbol('draggingHandled');\n\nvar Draggable =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Draggable, _React$Component);\n\n  function Draggable(props, context) {\n    var _this;\n\n    _classCallCheck(this, Draggable);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Draggable).call(this, props, context));\n    var delegate = {\n      onStart: function onStart(_ref) {\n        var x = _ref.x,\n            y = _ref.y;\n        var onStart = _this.props.onStart;\n        if (!onStart) return;\n        unstable_batchedUpdates(function () {\n          onStart({\n            x: x,\n            y: y\n          });\n        });\n      },\n      onMove: function onMove(_ref2) {\n        var x = _ref2.x,\n            y = _ref2.y;\n        var onUpdate = _this.props.onUpdate;\n        if (!onUpdate) return;\n        unstable_batchedUpdates(function () {\n          onUpdate({\n            x: x,\n            y: y\n          });\n        });\n      },\n      onEnd: function onEnd(_ref3) {\n        var x = _ref3.x,\n            y = _ref3.y;\n        var onEnd = _this.props.onEnd;\n        if (!onEnd) return;\n        unstable_batchedUpdates(function () {\n          onEnd({\n            x: x,\n            y: y\n          });\n        });\n      }\n    };\n    _this.mouseStrategy = new MouseStrategy(delegate);\n    _this.touchStrategy = new TouchStrategy(delegate);\n    _this.mouseDownListener = _this.mouseDownListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.touchStartListener = _this.touchStartListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.globalListener = _this.globalListener.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Draggable, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      getSharedEventEmitter().subscribe(this.globalListener);\n      this.setupNodeSubscription();\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var children = this.props.children;\n      return nextProps.children !== children;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.setupNodeSubscription();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      getSharedEventEmitter().unsubscribe(this.globalListener);\n    }\n  }, {\n    key: \"setupNodeSubscription\",\n    value: function setupNodeSubscription() {\n      // eslint-disable-next-line react/no-find-dom-node\n      var node$$1 = findDOMNode(this);\n      if (!node$$1) return;\n      node$$1.removeEventListener('mousedown', this.mouseDownListener);\n      node$$1.removeEventListener('touchstart', this.touchStartListener);\n      node$$1.addEventListener('mousedown', this.mouseDownListener, {\n        passive: true\n      });\n      node$$1.addEventListener('touchstart', this.touchStartListener, {\n        passive: true\n      });\n    }\n  }, {\n    key: \"mouseDownListener\",\n    value: function mouseDownListener(e) {\n      if (this.touchStrategy.isWaiting() || e[draggingHandled]) return;\n      this.mouseStrategy.start(e);\n      e[draggingHandled] = true;\n    }\n  }, {\n    key: \"touchStartListener\",\n    value: function touchStartListener(e) {\n      if (e[draggingHandled]) return;\n      this.touchStrategy.start(e);\n      e[draggingHandled] = true;\n    }\n  }, {\n    key: \"globalListener\",\n    value: function globalListener(_ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n          name = _ref5[0],\n          e = _ref5[1];\n\n      switch (name) {\n        case 'mousemove':\n          this.mouseStrategy.move(e);\n          break;\n\n        case 'mouseup':\n          this.mouseStrategy.end(e);\n          break;\n\n        case 'touchmove':\n          {\n            this.touchStrategy.move(e);\n            break;\n          }\n\n        case 'touchend':\n        case 'touchcancel':\n          {\n            this.touchStrategy.end(e);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      if (this.mouseStrategy.isDragging() || this.touchStrategy.isDragging()) {\n        clear();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children;\n    }\n  }]);\n\n  return Draggable;\n}(Component);\n\nprocess.env.NODE_ENV !== \"production\" ? Draggable.propTypes = {\n  children: node.isRequired,\n  onStart: func,\n  onUpdate: func,\n  onEnd: func\n} : void 0;\nDraggable.defaultProps = {\n  onStart: undefined,\n  onUpdate: undefined,\n  onEnd: undefined\n};\nvar DragDropContext = createContext();\n\nvar DragDropProviderCore =\n/*#__PURE__*/\nfunction () {\n  function DragDropProviderCore() {\n    _classCallCheck(this, DragDropProviderCore);\n\n    this.payload = null;\n    this.dragEmitter = new EventEmitter();\n  }\n\n  _createClass(DragDropProviderCore, [{\n    key: \"start\",\n    value: function start(payload, clientOffset) {\n      this.payload = payload;\n      this.dragEmitter.emit({\n        payload: this.payload,\n        clientOffset: clientOffset\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(clientOffset) {\n      this.dragEmitter.emit({\n        payload: this.payload,\n        clientOffset: clientOffset\n      });\n    }\n  }, {\n    key: \"end\",\n    value: function end(clientOffset) {\n      this.dragEmitter.emit({\n        payload: this.payload,\n        clientOffset: clientOffset,\n        end: true\n      });\n      this.payload = null;\n    }\n  }]);\n\n  return DragDropProviderCore;\n}();\n\nvar DragDropProvider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(DragDropProvider, _React$Component);\n\n  function DragDropProvider(props) {\n    var _this;\n\n    _classCallCheck(this, DragDropProvider);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DragDropProvider).call(this, props));\n    var onChange = _this.props.onChange;\n    _this.dragDropProvider = new DragDropProviderCore();\n\n    _this.dragDropProvider.dragEmitter.subscribe(function (_ref) {\n      var payload = _ref.payload,\n          clientOffset = _ref.clientOffset,\n          end = _ref.end;\n      onChange({\n        payload: end ? null : payload,\n        clientOffset: end ? null : clientOffset\n      });\n    });\n\n    return _this;\n  }\n\n  _createClass(DragDropProvider, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var children = this.props.children;\n      return nextProps.children !== children;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return createElement(DragDropContext.Provider, {\n        value: this.dragDropProvider\n      }, children);\n    }\n  }]);\n\n  return DragDropProvider;\n}(Component);\n\nprocess.env.NODE_ENV !== \"production\" ? DragDropProvider.propTypes = {\n  children: node.isRequired,\n  onChange: func\n} : void 0;\nDragDropProvider.defaultProps = {\n  onChange: function onChange() {}\n};\n\nvar DragSource =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(DragSource, _React$Component);\n\n  function DragSource() {\n    _classCallCheck(this, DragSource);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DragSource).apply(this, arguments));\n  }\n\n  _createClass(DragSource, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var children = this.props.children;\n      return nextProps.children !== children;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var dragDropProvider = this.context;\n      var _this$props = this.props,\n          _onStart = _this$props.onStart,\n          _onUpdate = _this$props.onUpdate,\n          _onEnd = _this$props.onEnd,\n          payload = _this$props.payload,\n          children = _this$props.children;\n      return createElement(Draggable, {\n        onStart: function onStart(_ref) {\n          var x = _ref.x,\n              y = _ref.y;\n          dragDropProvider.start(payload, {\n            x: x,\n            y: y\n          });\n\n          _onStart({\n            clientOffset: {\n              x: x,\n              y: y\n            }\n          });\n        },\n        onUpdate: function onUpdate(_ref2) {\n          var x = _ref2.x,\n              y = _ref2.y;\n          dragDropProvider.update({\n            x: x,\n            y: y\n          });\n\n          _onUpdate({\n            clientOffset: {\n              x: x,\n              y: y\n            }\n          });\n        },\n        onEnd: function onEnd(_ref3) {\n          var x = _ref3.x,\n              y = _ref3.y;\n          dragDropProvider.end({\n            x: x,\n            y: y\n          });\n\n          _onEnd({\n            clientOffset: {\n              x: x,\n              y: y\n            }\n          });\n        }\n      }, children);\n    }\n  }]);\n\n  return DragSource;\n}(Component);\n\nDragSource.contextType = DragDropContext;\nprocess.env.NODE_ENV !== \"production\" ? DragSource.propTypes = {\n  children: node.isRequired,\n  payload: any.isRequired,\n  onStart: func,\n  onUpdate: func,\n  onEnd: func\n} : void 0;\nDragSource.defaultProps = {\n  onStart: function onStart() {},\n  onUpdate: function onUpdate() {},\n  onEnd: function onEnd() {}\n};\n\nvar clamp$1 = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar DropTarget =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(DropTarget, _React$Component);\n\n  function DropTarget(props) {\n    var _this;\n\n    _classCallCheck(this, DropTarget);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropTarget).call(this, props));\n    _this.node = null;\n    _this.isOver = false;\n    _this.handleDrag = _this.handleDrag.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(DropTarget, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var dragEmitter = this.context.dragEmitter;\n      dragEmitter.subscribe(this.handleDrag);\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps) {\n      var children = this.props.children;\n      return nextProps.children !== children;\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var dragEmitter = this.context.dragEmitter;\n      dragEmitter.unsubscribe(this.handleDrag);\n    }\n  }, {\n    key: \"handleDrag\",\n    value: function handleDrag(_ref) {\n      var payload = _ref.payload,\n          clientOffset = _ref.clientOffset,\n          end = _ref.end;\n\n      var _findDOMNode$getBound = findDOMNode(this).getBoundingClientRect(),\n          left = _findDOMNode$getBound.left,\n          top = _findDOMNode$getBound.top,\n          right = _findDOMNode$getBound.right,\n          bottom = _findDOMNode$getBound.bottom; // eslint-disable-line react/no-find-dom-node\n\n\n      var _this$props = this.props,\n          onDrop = _this$props.onDrop,\n          onEnter = _this$props.onEnter,\n          onLeave = _this$props.onLeave,\n          onOver = _this$props.onOver;\n      var isOver = clientOffset && clamp$1(clientOffset.x, left, right) === clientOffset.x && clamp$1(clientOffset.y, top, bottom) === clientOffset.y;\n      if (!this.isOver && isOver) onEnter({\n        payload: payload,\n        clientOffset: clientOffset\n      });\n      if (this.isOver && isOver) onOver({\n        payload: payload,\n        clientOffset: clientOffset\n      });\n      if (this.isOver && !isOver) onLeave({\n        payload: payload,\n        clientOffset: clientOffset\n      });\n      if (isOver && end) onDrop({\n        payload: payload,\n        clientOffset: clientOffset\n      });\n      this.isOver = isOver && !end;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return Children.only(children);\n    }\n  }]);\n\n  return DropTarget;\n}(Component);\n\nDropTarget.contextType = DragDropContext;\nprocess.env.NODE_ENV !== \"production\" ? DropTarget.propTypes = {\n  children: node.isRequired,\n  onEnter: func,\n  onOver: func,\n  onLeave: func,\n  onDrop: func\n} : void 0;\nDropTarget.defaultProps = {\n  onEnter: function onEnter() {},\n  onOver: function onOver() {},\n  onLeave: function onLeave() {},\n  onDrop: function onDrop() {}\n};\n\nvar RefHolder =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(RefHolder, _React$PureComponent);\n\n  function RefHolder() {\n    _classCallCheck(this, RefHolder);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RefHolder).apply(this, arguments));\n  }\n\n  _createClass(RefHolder, [{\n    key: \"render\",\n    value: function render() {\n      var children = this.props.children;\n      return children;\n    }\n  }]);\n\n  return RefHolder;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RefHolder.propTypes = {\n  children: node.isRequired\n} : void 0;\nvar styles = {\n  triggersRoot: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'hidden',\n    zIndex: -1,\n    visibility: 'hidden',\n    opacity: 0\n  },\n  expandTrigger: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'auto'\n  },\n  contractTrigger: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    overflow: 'auto',\n    minHeight: '1px',\n    minWidth: '1px'\n  },\n  contractNotifier: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '200%',\n    height: '200%'\n  }\n};\n\nvar Sizer =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Sizer, _React$PureComponent);\n\n  function Sizer(props) {\n    var _this;\n\n    _classCallCheck(this, Sizer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Sizer).call(this, props));\n    _this.setupListeners = _this.setupListeners.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.rootRef = createRef();\n    return _this;\n  }\n\n  _createClass(Sizer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.createListeners();\n      this.setupListeners();\n    }\n  }, {\n    key: \"setupListeners\",\n    value: function setupListeners() {\n      // eslint-disable-next-line react/no-find-dom-node\n      var rootNode = findDOMNode(this.rootRef.current);\n      var size = {\n        height: rootNode.clientHeight,\n        width: rootNode.clientWidth\n      };\n      this.contractTrigger.scrollTop = size.height;\n      this.contractTrigger.scrollLeft = size.width;\n      this.expandNotifier.style.width = \"\".concat(size.width + 1, \"px\");\n      this.expandNotifier.style.height = \"\".concat(size.height + 1, \"px\");\n      this.expandTrigger.scrollTop = 1;\n      this.expandTrigger.scrollLeft = 1;\n      var onSizeChange = this.props.onSizeChange;\n      onSizeChange(size);\n    }\n  }, {\n    key: \"createListeners\",\n    value: function createListeners() {\n      // eslint-disable-next-line react/no-find-dom-node\n      var rootNode = findDOMNode(this.rootRef.current);\n      this.triggersRoot = document.createElement('div');\n      Object.assign(this.triggersRoot.style, styles.triggersRoot);\n      rootNode.appendChild(this.triggersRoot);\n      this.expandTrigger = document.createElement('div');\n      Object.assign(this.expandTrigger.style, styles.expandTrigger);\n      this.expandTrigger.addEventListener('scroll', this.setupListeners);\n      this.triggersRoot.appendChild(this.expandTrigger);\n      this.expandNotifier = document.createElement('div');\n      this.expandTrigger.appendChild(this.expandNotifier);\n      this.contractTrigger = document.createElement('div');\n      Object.assign(this.contractTrigger.style, styles.contractTrigger);\n      this.contractTrigger.addEventListener('scroll', this.setupListeners);\n      this.triggersRoot.appendChild(this.contractTrigger);\n      this.contractNotifier = document.createElement('div');\n      Object.assign(this.contractNotifier.style, styles.contractNotifier);\n      this.contractTrigger.appendChild(this.contractNotifier);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          onSizeChange = _this$props.onSizeChange,\n          Container = _this$props.containerComponent,\n          restProps = _objectWithoutProperties(_this$props, [\"onSizeChange\", \"containerComponent\"]);\n\n      return createElement(RefHolder, {\n        ref: this.rootRef\n      }, createElement(Container // NOTE: should have `position: relative`\n      , restProps));\n    }\n  }]);\n\n  return Sizer;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Sizer.propTypes = {\n  onSizeChange: func.isRequired,\n  containerComponent: oneOfType([string, func])\n} : void 0;\nSizer.defaultProps = {\n  containerComponent: 'div'\n};\n\nvar connectProps = function connectProps(WrappedComponent, getAdditionalProps) {\n  var storedAdditionalProps = getAdditionalProps();\n  var components = new Set();\n\n  var RenderComponent =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(RenderComponent, _React$PureComponent);\n\n    function RenderComponent() {\n      _classCallCheck(this, RenderComponent);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(RenderComponent).apply(this, arguments));\n    }\n\n    _createClass(RenderComponent, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        components.add(this);\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        components.delete(this);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return createElement(WrappedComponent, _extends({}, this.props, storedAdditionalProps));\n      }\n    }]);\n\n    return RenderComponent;\n  }(PureComponent);\n\n  RenderComponent.update = function () {\n    storedAdditionalProps = getAdditionalProps();\n    Array.from(components.values()).forEach(function (component) {\n      return component.forceUpdate();\n    });\n  };\n\n  return RenderComponent;\n};\n\nvar createStateHelper = function createStateHelper(component) {\n  var controlledStateProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var notifyStateChange = function notifyStateChange(nextState, state) {\n    Object.keys(controlledStateProperties).forEach(function (propertyName) {\n      var changeEvent = controlledStateProperties[propertyName]();\n\n      if (changeEvent && nextState[propertyName] !== state[propertyName]) {\n        changeEvent(nextState[propertyName]);\n      }\n    });\n  };\n\n  var lastStateUpdater = null;\n  var initialState = null;\n  var lastInitialState = null;\n\n  var applyReducer = function applyReducer(reduce, payload, callback) {\n    var stateUpdater = function stateUpdater(prevState) {\n      if (initialState === null) {\n        initialState = prevState;\n      }\n\n      var stateChange = reduce(_objectSpread({}, prevState), payload);\n\n      var state = _objectSpread({}, prevState, stateChange);\n\n      if (typeof callback === 'function') {\n        callback(state, prevState);\n      }\n\n      if (stateUpdater === lastStateUpdater) {\n        if (lastInitialState !== initialState) {\n          notifyStateChange(state, initialState);\n          lastInitialState = initialState;\n        }\n\n        initialState = null;\n      }\n\n      return stateChange;\n    };\n\n    lastStateUpdater = stateUpdater;\n    component.setState(stateUpdater);\n  };\n\n  var applyFieldReducer = function applyFieldReducer(field, reduce, payload) {\n    applyReducer(function (state) {\n      return _defineProperty({}, field, reduce(state[field], payload));\n    });\n  };\n\n  return {\n    applyReducer: applyReducer,\n    applyFieldReducer: applyFieldReducer\n  };\n};\n\nvar makeBoundComponent = function makeBoundComponent(Target, components, exposed) {\n  var Component$$1 =\n  /*#__PURE__*/\n  function (_React$PureComponent) {\n    _inherits(Component$$1, _React$PureComponent);\n\n    function Component$$1() {\n      _classCallCheck(this, Component$$1);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(Component$$1).apply(this, arguments));\n    }\n\n    _createClass(Component$$1, [{\n      key: \"render\",\n      value: function render() {\n        return createElement(Target, _extends({}, components, this.props));\n      }\n    }]);\n\n    return Component$$1;\n  }(PureComponent);\n\n  Component$$1.components = Target.components;\n  Object.assign(Component$$1, exposed);\n  return Component$$1;\n};\n\nvar withComponents = function withComponents(components) {\n  return function (Target) {\n    var props = {};\n    var exposed = {};\n    Object.entries(Target.components).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          fieldName = _ref2[0],\n          componentName = _ref2[1];\n\n      var component = components[componentName];\n\n      if (component && component !== Target[componentName]) {\n        props[fieldName] = component;\n      }\n\n      exposed[componentName] = component || Target[componentName];\n    });\n    return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;\n  };\n};\n/* globals Element */\n\n\nvar RefType = shape({\n  current: instanceOf(typeof Element !== 'undefined' ? Element : Object)\n});\nexport { Plugin, PluginHost$1 as PluginHost, Action, Getter, Template, TemplatePlaceholder, TemplateConnector, Draggable, DragDropProvider, DragSource, DropTarget, Sizer, RefHolder, connectProps, createStateHelper, withComponents, RefType };","map":null,"metadata":{},"sourceType":"module"}